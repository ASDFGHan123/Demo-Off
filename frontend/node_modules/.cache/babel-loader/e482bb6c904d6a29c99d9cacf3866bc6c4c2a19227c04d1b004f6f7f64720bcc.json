{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    this.reconnectTimeout = null;\n    this.heartbeatInterval = null;\n    this.lastHeartbeat = Date.now();\n    this.messageCallbacks = [];\n    this.reactionCallbacks = [];\n    this.userStatusCallbacks = [];\n    this.notificationCallbacks = [];\n    this.messageEditedCallbacks = [];\n    this.messageDeletedCallbacks = [];\n    this.readReceiptCallbacks = [];\n    this.connectionPromise = null;\n  }\n  connect(roomName) {\n    console.log(`[WebSocket Debug] Attempting to connect to room: ${roomName}`);\n    if (this.connectionPromise) {\n      console.log('[WebSocket Debug] Returning existing connection promise');\n      return this.connectionPromise;\n    }\n    this.connectionPromise = new Promise((resolve, reject) => {\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n        console.log('[WebSocket Debug] Socket already open, resolving immediately');\n        resolve(this.socket);\n        return;\n      }\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const wsUrl = `${protocol}//${window.location.host}/ws/chat/${roomName}/`;\n      console.log(`[WebSocket Debug] Connecting to URL: ${wsUrl}`);\n      this.socket = new WebSocket(wsUrl);\n      this.socket.onopen = () => {\n        console.log('[WebSocket Debug] WebSocket connected successfully');\n        this.reconnectAttempts = 0;\n        this.startHeartbeat();\n        resolve(this.socket);\n      };\n      this.socket.onclose = event => {\n        console.log(`[WebSocket Debug] WebSocket disconnected: code=${event.code}, reason=${event.reason}, wasClean=${event.wasClean}`);\n        this.stopHeartbeat();\n        this.connectionPromise = null;\n        if (event.code !== 1000) {\n          // Not a normal closure\n          console.log('[WebSocket Debug] Non-normal closure, attempting reconnect');\n          this.attemptReconnect(roomName);\n        } else {\n          console.log('[WebSocket Debug] Normal closure, not reconnecting');\n        }\n      };\n      this.socket.onerror = error => {\n        console.error('[WebSocket Debug] WebSocket connection error:', error);\n        this.connectionPromise = null;\n        reject(error);\n        this.attemptReconnect(roomName);\n      };\n      this.socket.onmessage = event => {\n        console.log(`[WebSocket Debug] Received message: ${event.data.substring(0, 100)}${event.data.length > 100 ? '...' : ''}`);\n        this.lastHeartbeat = Date.now();\n        try {\n          const data = JSON.parse(event.data);\n          console.log(`[WebSocket Debug] Parsed message type: ${data.type || 'regular_message'}`);\n          this.handleMessage(data);\n        } catch (e) {\n          console.error('[WebSocket Debug] Failed to parse WebSocket message:', e, 'Raw data:', event.data);\n        }\n      };\n    });\n    return this.connectionPromise;\n  }\n  handleMessage(data) {\n    console.log(`[WebSocket Debug] Handling message type: ${data.type || 'regular_message'}`);\n    if (data.type === 'reaction') {\n      console.log('[WebSocket Debug] Processing reaction message');\n      this.reactionCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'user_status') {\n      console.log('[WebSocket Debug] Processing user status message');\n      this.userStatusCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'notification') {\n      console.log('[WebSocket Debug] Processing notification message');\n      this.notificationCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'message_edited') {\n      console.log('[WebSocket Debug] Processing message edited message');\n      this.messageEditedCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'message_deleted') {\n      console.log('[WebSocket Debug] Processing message deleted message');\n      this.messageDeletedCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'read_receipt') {\n      console.log('[WebSocket Debug] Processing read receipt message');\n      this.readReceiptCallbacks.forEach(callback => callback(data));\n    } else {\n      // Assume it's a regular message\n      console.log('[WebSocket Debug] Processing regular message');\n      this.messageCallbacks.forEach(callback => callback(data));\n    }\n  }\n  startHeartbeat() {\n    this.heartbeatInterval = setInterval(() => {\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n        // Send ping every 30 seconds\n        this.socket.send(JSON.stringify({\n          type: 'ping'\n        }));\n      }\n    }, 30000);\n\n    // Check for pong responses\n    this.socket.onmessage = event => {\n      this.lastHeartbeat = Date.now();\n      try {\n        const data = JSON.parse(event.data);\n        if (data.type === 'pong') {\n          return; // Heartbeat response, don't process as message\n        }\n        this.handleMessage(data);\n      } catch (e) {\n        console.error('Failed to parse WebSocket message:', e);\n      }\n    };\n  }\n  stopHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n  attemptReconnect(roomName) {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect(roomName).catch(() => {\n          // Connection failed, will retry in next attempt\n        });\n      }, this.reconnectDelay * this.reconnectAttempts);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n  disconnect() {\n    this.stopHeartbeat();\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket) {\n      this.socket.close(1000, 'Client disconnect');\n      this.socket = null;\n    }\n    this.connectionPromise = null;\n    this.reconnectAttempts = 0;\n  }\n  sendMessage(message) {\n    console.log(`[WebSocket Debug] Sending message: ${JSON.stringify(message)}`);\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      const payload = JSON.stringify({\n        message: message.message,\n        reply_to: message.reply_to\n      });\n      console.log(`[WebSocket Debug] Sending payload: ${payload}`);\n      this.socket.send(payload);\n    } else {\n      console.error('[WebSocket Debug] Cannot send message: socket not open or null');\n    }\n  }\n  sendReaction(messageId, emoji) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'reaction',\n        message_id: messageId,\n        emoji\n      }));\n    }\n  }\n  sendReadReceipt(messageId) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'read_receipt',\n        message_id: messageId\n      }));\n    }\n  }\n  editMessage(messageId, content) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'edit_message',\n        message_id: messageId,\n        content\n      }));\n    }\n  }\n  deleteMessage(messageId) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'delete_message',\n        message_id: messageId\n      }));\n    }\n  }\n  replyToMessage(messageId, content, replyToId) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        message: content,\n        reply_to: replyToId\n      }));\n    }\n  }\n  onMessage(callback) {\n    this.messageCallbacks.push(callback);\n  }\n  onReaction(callback) {\n    this.reactionCallbacks.push(callback);\n  }\n  onUserStatus(callback) {\n    this.userStatusCallbacks.push(callback);\n  }\n  onNotification(callback) {\n    this.notificationCallbacks.push(callback);\n  }\n  onMessageEdited(callback) {\n    this.messageEditedCallbacks.push(callback);\n  }\n  onMessageDeleted(callback) {\n    this.messageDeletedCallbacks.push(callback);\n  }\n  onReadReceipt(callback) {\n    this.readReceiptCallbacks.push(callback);\n  }\n  off(event, callback) {\n    let callbacks = [];\n    switch (event) {\n      case 'message':\n        callbacks = this.messageCallbacks;\n        break;\n      case 'reaction':\n        callbacks = this.reactionCallbacks;\n        break;\n      case 'user_status':\n        callbacks = this.userStatusCallbacks;\n        break;\n      case 'notification':\n        callbacks = this.notificationCallbacks;\n        break;\n      case 'message_edited':\n        callbacks = this.messageEditedCallbacks;\n        break;\n      case 'message_deleted':\n        callbacks = this.messageDeletedCallbacks;\n        break;\n      case 'read_receipt':\n        callbacks = this.readReceiptCallbacks;\n        break;\n    }\n    if (callback) {\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    } else {\n      callbacks.length = 0;\n    }\n  }\n}\nexport default new WebSocketService();","map":{"version":3,"names":["WebSocketService","constructor","socket","reconnectAttempts","maxReconnectAttempts","reconnectDelay","reconnectTimeout","heartbeatInterval","lastHeartbeat","Date","now","messageCallbacks","reactionCallbacks","userStatusCallbacks","notificationCallbacks","messageEditedCallbacks","messageDeletedCallbacks","readReceiptCallbacks","connectionPromise","connect","roomName","console","log","Promise","resolve","reject","readyState","WebSocket","OPEN","protocol","window","location","wsUrl","host","onopen","startHeartbeat","onclose","event","code","reason","wasClean","stopHeartbeat","attemptReconnect","onerror","error","onmessage","data","substring","length","JSON","parse","type","handleMessage","e","forEach","callback","setInterval","send","stringify","clearInterval","setTimeout","catch","disconnect","clearTimeout","close","sendMessage","message","payload","reply_to","sendReaction","messageId","emoji","message_id","sendReadReceipt","editMessage","content","deleteMessage","replyToMessage","replyToId","onMessage","push","onReaction","onUserStatus","onNotification","onMessageEdited","onMessageDeleted","onReadReceipt","off","callbacks","index","indexOf","splice"],"sources":["c:/Users/salaam/Desktop/OffChat/frontend/src/services/websocket.ts"],"sourcesContent":["class WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectDelay = 1000;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private heartbeatInterval: NodeJS.Timeout | null = null;\r\n  private lastHeartbeat = Date.now();\r\n  private messageCallbacks: ((data: any) => void)[] = [];\r\n  private reactionCallbacks: ((data: any) => void)[] = [];\r\n  private userStatusCallbacks: ((data: any) => void)[] = [];\r\n  private notificationCallbacks: ((data: any) => void)[] = [];\r\n  private messageEditedCallbacks: ((data: any) => void)[] = [];\r\n  private messageDeletedCallbacks: ((data: any) => void)[] = [];\r\n  private readReceiptCallbacks: ((data: any) => void)[] = [];\r\n  private connectionPromise: Promise<WebSocket> | null = null;\r\n\r\n  connect(roomName: string): Promise<WebSocket> {\r\n    console.log(`[WebSocket Debug] Attempting to connect to room: ${roomName}`);\r\n    if (this.connectionPromise) {\r\n      console.log('[WebSocket Debug] Returning existing connection promise');\r\n      return this.connectionPromise;\r\n    }\r\n\r\n    this.connectionPromise = new Promise((resolve, reject) => {\r\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n        console.log('[WebSocket Debug] Socket already open, resolving immediately');\r\n        resolve(this.socket);\r\n        return;\r\n      }\r\n\r\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n      const wsUrl = `${protocol}//${window.location.host}/ws/chat/${roomName}/`;\r\n      console.log(`[WebSocket Debug] Connecting to URL: ${wsUrl}`);\r\n\r\n      this.socket = new WebSocket(wsUrl);\r\n\r\n      this.socket.onopen = () => {\r\n        console.log('[WebSocket Debug] WebSocket connected successfully');\r\n        this.reconnectAttempts = 0;\r\n        this.startHeartbeat();\r\n        resolve(this.socket!);\r\n      };\r\n\r\n      this.socket.onclose = (event) => {\r\n        console.log(`[WebSocket Debug] WebSocket disconnected: code=${event.code}, reason=${event.reason}, wasClean=${event.wasClean}`);\r\n        this.stopHeartbeat();\r\n        this.connectionPromise = null;\r\n        if (event.code !== 1000) { // Not a normal closure\r\n          console.log('[WebSocket Debug] Non-normal closure, attempting reconnect');\r\n          this.attemptReconnect(roomName);\r\n        } else {\r\n          console.log('[WebSocket Debug] Normal closure, not reconnecting');\r\n        }\r\n      };\r\n\r\n      this.socket.onerror = (error) => {\r\n        console.error('[WebSocket Debug] WebSocket connection error:', error);\r\n        this.connectionPromise = null;\r\n        reject(error);\r\n        this.attemptReconnect(roomName);\r\n      };\r\n\r\n      this.socket.onmessage = (event) => {\r\n        console.log(`[WebSocket Debug] Received message: ${event.data.substring(0, 100)}${event.data.length > 100 ? '...' : ''}`);\r\n        this.lastHeartbeat = Date.now();\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          console.log(`[WebSocket Debug] Parsed message type: ${data.type || 'regular_message'}`);\r\n          this.handleMessage(data);\r\n        } catch (e) {\r\n          console.error('[WebSocket Debug] Failed to parse WebSocket message:', e, 'Raw data:', event.data);\r\n        }\r\n      };\r\n    });\r\n\r\n    return this.connectionPromise;\r\n  }\r\n\r\n  private handleMessage(data: any) {\r\n    console.log(`[WebSocket Debug] Handling message type: ${data.type || 'regular_message'}`);\r\n    if (data.type === 'reaction') {\r\n      console.log('[WebSocket Debug] Processing reaction message');\r\n      this.reactionCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'user_status') {\r\n      console.log('[WebSocket Debug] Processing user status message');\r\n      this.userStatusCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'notification') {\r\n      console.log('[WebSocket Debug] Processing notification message');\r\n      this.notificationCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'message_edited') {\r\n      console.log('[WebSocket Debug] Processing message edited message');\r\n      this.messageEditedCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'message_deleted') {\r\n      console.log('[WebSocket Debug] Processing message deleted message');\r\n      this.messageDeletedCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'read_receipt') {\r\n      console.log('[WebSocket Debug] Processing read receipt message');\r\n      this.readReceiptCallbacks.forEach(callback => callback(data));\r\n    } else {\r\n      // Assume it's a regular message\r\n      console.log('[WebSocket Debug] Processing regular message');\r\n      this.messageCallbacks.forEach(callback => callback(data));\r\n    }\r\n  }\r\n\r\n  private startHeartbeat() {\r\n    this.heartbeatInterval = setInterval(() => {\r\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n        // Send ping every 30 seconds\r\n        this.socket.send(JSON.stringify({ type: 'ping' }));\r\n      }\r\n    }, 30000);\r\n\r\n    // Check for pong responses\r\n    this.socket!.onmessage = (event) => {\r\n      this.lastHeartbeat = Date.now();\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n        if (data.type === 'pong') {\r\n          return; // Heartbeat response, don't process as message\r\n        }\r\n        this.handleMessage(data);\r\n      } catch (e) {\r\n        console.error('Failed to parse WebSocket message:', e);\r\n      }\r\n    };\r\n  }\r\n\r\n  private stopHeartbeat() {\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n      this.heartbeatInterval = null;\r\n    }\r\n  }\r\n\r\n  private attemptReconnect(roomName: string) {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.connect(roomName).catch(() => {\r\n          // Connection failed, will retry in next attempt\r\n        });\r\n      }, this.reconnectDelay * this.reconnectAttempts);\r\n    } else {\r\n      console.error('Max reconnection attempts reached');\r\n    }\r\n  }\r\n\r\n  disconnect() {\r\n    this.stopHeartbeat();\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    if (this.socket) {\r\n      this.socket.close(1000, 'Client disconnect');\r\n      this.socket = null;\r\n    }\r\n    this.connectionPromise = null;\r\n    this.reconnectAttempts = 0;\r\n  }\r\n\r\n  sendMessage(message: any) {\r\n    console.log(`[WebSocket Debug] Sending message: ${JSON.stringify(message)}`);\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      const payload = JSON.stringify({\r\n        message: message.message,\r\n        reply_to: message.reply_to\r\n      });\r\n      console.log(`[WebSocket Debug] Sending payload: ${payload}`);\r\n      this.socket.send(payload);\r\n    } else {\r\n      console.error('[WebSocket Debug] Cannot send message: socket not open or null');\r\n    }\r\n  }\r\n\r\n  sendReaction(messageId: number, emoji: string) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'reaction',\r\n        message_id: messageId,\r\n        emoji\r\n      }));\r\n    }\r\n  }\r\n\r\n  sendReadReceipt(messageId: number) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'read_receipt',\r\n        message_id: messageId\r\n      }));\r\n    }\r\n  }\r\n\r\n  editMessage(messageId: number, content: string) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'edit_message',\r\n        message_id: messageId,\r\n        content\r\n      }));\r\n    }\r\n  }\r\n\r\n  deleteMessage(messageId: number) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'delete_message',\r\n        message_id: messageId\r\n      }));\r\n    }\r\n  }\r\n\r\n  replyToMessage(messageId: number, content: string, replyToId?: number) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        message: content,\r\n        reply_to: replyToId\r\n      }));\r\n    }\r\n  }\r\n\r\n  onMessage(callback: (data: any) => void) {\r\n    this.messageCallbacks.push(callback);\r\n  }\r\n\r\n  onReaction(callback: (data: any) => void) {\r\n    this.reactionCallbacks.push(callback);\r\n  }\r\n\r\n  onUserStatus(callback: (data: any) => void) {\r\n    this.userStatusCallbacks.push(callback);\r\n  }\r\n\r\n  onNotification(callback: (data: any) => void) {\r\n    this.notificationCallbacks.push(callback);\r\n  }\r\n\r\n  onMessageEdited(callback: (data: any) => void) {\r\n    this.messageEditedCallbacks.push(callback);\r\n  }\r\n\r\n  onMessageDeleted(callback: (data: any) => void) {\r\n    this.messageDeletedCallbacks.push(callback);\r\n  }\r\n\r\n  onReadReceipt(callback: (data: any) => void) {\r\n    this.readReceiptCallbacks.push(callback);\r\n  }\r\n\r\n  off(event: string, callback?: (data: any) => void) {\r\n    let callbacks: ((data: any) => void)[] = [];\r\n    switch (event) {\r\n      case 'message':\r\n        callbacks = this.messageCallbacks;\r\n        break;\r\n      case 'reaction':\r\n        callbacks = this.reactionCallbacks;\r\n        break;\r\n      case 'user_status':\r\n        callbacks = this.userStatusCallbacks;\r\n        break;\r\n      case 'notification':\r\n        callbacks = this.notificationCallbacks;\r\n        break;\r\n      case 'message_edited':\r\n        callbacks = this.messageEditedCallbacks;\r\n        break;\r\n      case 'message_deleted':\r\n        callbacks = this.messageDeletedCallbacks;\r\n        break;\r\n      case 'read_receipt':\r\n        callbacks = this.readReceiptCallbacks;\r\n        break;\r\n    }\r\n    if (callback) {\r\n      const index = callbacks.indexOf(callback);\r\n      if (index > -1) {\r\n        callbacks.splice(index, 1);\r\n      }\r\n    } else {\r\n      callbacks.length = 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new WebSocketService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}