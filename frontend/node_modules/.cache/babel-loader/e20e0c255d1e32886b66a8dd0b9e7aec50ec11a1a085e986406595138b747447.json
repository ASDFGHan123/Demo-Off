{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    this.reconnectTimeout = null;\n    this.heartbeatInterval = null;\n    this.lastHeartbeat = Date.now();\n    this.messageCallbacks = [];\n    this.reactionCallbacks = [];\n    this.userStatusCallbacks = [];\n    this.notificationCallbacks = [];\n    this.messageEditedCallbacks = [];\n    this.messageDeletedCallbacks = [];\n    this.readReceiptCallbacks = [];\n    this.connectionPromise = null;\n  }\n  connect(roomName) {\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n    this.connectionPromise = new Promise((resolve, reject) => {\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n        resolve(this.socket);\n        return;\n      }\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      const wsUrl = `${protocol}//${window.location.host}/ws/chat/${roomName}/`;\n      this.socket = new WebSocket(wsUrl);\n      this.socket.onopen = () => {\n        console.log('WebSocket connected');\n        this.reconnectAttempts = 0;\n        this.startHeartbeat();\n        resolve(this.socket);\n      };\n      this.socket.onclose = event => {\n        console.log('WebSocket disconnected:', event.code, event.reason);\n        this.stopHeartbeat();\n        this.connectionPromise = null;\n        if (event.code !== 1000) {\n          // Not a normal closure\n          this.attemptReconnect(roomName);\n        }\n      };\n      this.socket.onerror = error => {\n        console.error('WebSocket connection error:', error);\n        this.connectionPromise = null;\n        reject(error);\n        this.attemptReconnect(roomName);\n      };\n      this.socket.onmessage = event => {\n        this.lastHeartbeat = Date.now();\n        try {\n          const data = JSON.parse(event.data);\n          this.handleMessage(data);\n        } catch (e) {\n          console.error('Failed to parse WebSocket message:', e);\n        }\n      };\n    });\n    return this.connectionPromise;\n  }\n  handleMessage(data) {\n    if (data.type === 'reaction') {\n      this.reactionCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'user_status') {\n      this.userStatusCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'notification') {\n      this.notificationCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'message_edited') {\n      this.messageEditedCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'message_deleted') {\n      this.messageDeletedCallbacks.forEach(callback => callback(data));\n    } else if (data.type === 'read_receipt') {\n      this.readReceiptCallbacks.forEach(callback => callback(data));\n    } else {\n      // Assume it's a regular message\n      this.messageCallbacks.forEach(callback => callback(data));\n    }\n  }\n  startHeartbeat() {\n    this.heartbeatInterval = setInterval(() => {\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n        // Send ping every 30 seconds\n        this.socket.send(JSON.stringify({\n          type: 'ping'\n        }));\n      }\n    }, 30000);\n\n    // Check for pong responses\n    this.socket.onmessage = event => {\n      this.lastHeartbeat = Date.now();\n      try {\n        const data = JSON.parse(event.data);\n        if (data.type === 'pong') {\n          return; // Heartbeat response, don't process as message\n        }\n        this.handleMessage(data);\n      } catch (e) {\n        console.error('Failed to parse WebSocket message:', e);\n      }\n    };\n  }\n  stopHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n  attemptReconnect(roomName) {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect(roomName).catch(() => {\n          // Connection failed, will retry in next attempt\n        });\n      }, this.reconnectDelay * this.reconnectAttempts);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n  disconnect() {\n    this.stopHeartbeat();\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.socket) {\n      this.socket.close(1000, 'Client disconnect');\n      this.socket = null;\n    }\n    this.connectionPromise = null;\n    this.reconnectAttempts = 0;\n  }\n  sendMessage(message) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        message: message.message,\n        reply_to: message.reply_to\n      }));\n    }\n  }\n  sendReaction(messageId, emoji) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'reaction',\n        message_id: messageId,\n        emoji\n      }));\n    }\n  }\n  sendReadReceipt(messageId) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'read_receipt',\n        message_id: messageId\n      }));\n    }\n  }\n  editMessage(messageId, content) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'edit_message',\n        message_id: messageId,\n        content\n      }));\n    }\n  }\n  deleteMessage(messageId) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        type: 'delete_message',\n        message_id: messageId\n      }));\n    }\n  }\n  replyToMessage(messageId, content, replyToId) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({\n        message: content,\n        reply_to: replyToId\n      }));\n    }\n  }\n  onMessage(callback) {\n    this.messageCallbacks.push(callback);\n  }\n  onReaction(callback) {\n    this.reactionCallbacks.push(callback);\n  }\n  onUserStatus(callback) {\n    this.userStatusCallbacks.push(callback);\n  }\n  onNotification(callback) {\n    this.notificationCallbacks.push(callback);\n  }\n  onMessageEdited(callback) {\n    this.messageEditedCallbacks.push(callback);\n  }\n  onMessageDeleted(callback) {\n    this.messageDeletedCallbacks.push(callback);\n  }\n  onReadReceipt(callback) {\n    this.readReceiptCallbacks.push(callback);\n  }\n  off(event, callback) {\n    let callbacks = [];\n    switch (event) {\n      case 'message':\n        callbacks = this.messageCallbacks;\n        break;\n      case 'reaction':\n        callbacks = this.reactionCallbacks;\n        break;\n      case 'user_status':\n        callbacks = this.userStatusCallbacks;\n        break;\n      case 'notification':\n        callbacks = this.notificationCallbacks;\n        break;\n      case 'message_edited':\n        callbacks = this.messageEditedCallbacks;\n        break;\n      case 'message_deleted':\n        callbacks = this.messageDeletedCallbacks;\n        break;\n      case 'read_receipt':\n        callbacks = this.readReceiptCallbacks;\n        break;\n    }\n    if (callback) {\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    } else {\n      callbacks.length = 0;\n    }\n  }\n}\nexport default new WebSocketService();","map":{"version":3,"names":["WebSocketService","constructor","socket","reconnectAttempts","maxReconnectAttempts","reconnectDelay","reconnectTimeout","heartbeatInterval","lastHeartbeat","Date","now","messageCallbacks","reactionCallbacks","userStatusCallbacks","notificationCallbacks","messageEditedCallbacks","messageDeletedCallbacks","readReceiptCallbacks","connectionPromise","connect","roomName","Promise","resolve","reject","readyState","WebSocket","OPEN","protocol","window","location","wsUrl","host","onopen","console","log","startHeartbeat","onclose","event","code","reason","stopHeartbeat","attemptReconnect","onerror","error","onmessage","data","JSON","parse","handleMessage","e","type","forEach","callback","setInterval","send","stringify","clearInterval","setTimeout","catch","disconnect","clearTimeout","close","sendMessage","message","reply_to","sendReaction","messageId","emoji","message_id","sendReadReceipt","editMessage","content","deleteMessage","replyToMessage","replyToId","onMessage","push","onReaction","onUserStatus","onNotification","onMessageEdited","onMessageDeleted","onReadReceipt","off","callbacks","index","indexOf","splice","length"],"sources":["C:/Users/salaam/Desktop/OffChat/frontend/src/services/websocket.ts"],"sourcesContent":["class WebSocketService {\r\n  private socket: WebSocket | null = null;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectDelay = 1000;\r\n  private reconnectTimeout: NodeJS.Timeout | null = null;\r\n  private heartbeatInterval: NodeJS.Timeout | null = null;\r\n  private lastHeartbeat = Date.now();\r\n  private messageCallbacks: ((data: any) => void)[] = [];\r\n  private reactionCallbacks: ((data: any) => void)[] = [];\r\n  private userStatusCallbacks: ((data: any) => void)[] = [];\r\n  private notificationCallbacks: ((data: any) => void)[] = [];\r\n  private messageEditedCallbacks: ((data: any) => void)[] = [];\r\n  private messageDeletedCallbacks: ((data: any) => void)[] = [];\r\n  private readReceiptCallbacks: ((data: any) => void)[] = [];\r\n  private connectionPromise: Promise<WebSocket> | null = null;\r\n\r\n  connect(roomName: string): Promise<WebSocket> {\r\n    if (this.connectionPromise) {\r\n      return this.connectionPromise;\r\n    }\r\n\r\n    this.connectionPromise = new Promise((resolve, reject) => {\r\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n        resolve(this.socket);\r\n        return;\r\n      }\r\n\r\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n      const wsUrl = `${protocol}//${window.location.host}/ws/chat/${roomName}/`;\r\n\r\n      this.socket = new WebSocket(wsUrl);\r\n\r\n      this.socket.onopen = () => {\r\n        console.log('WebSocket connected');\r\n        this.reconnectAttempts = 0;\r\n        this.startHeartbeat();\r\n        resolve(this.socket!);\r\n      };\r\n\r\n      this.socket.onclose = (event) => {\r\n        console.log('WebSocket disconnected:', event.code, event.reason);\r\n        this.stopHeartbeat();\r\n        this.connectionPromise = null;\r\n        if (event.code !== 1000) { // Not a normal closure\r\n          this.attemptReconnect(roomName);\r\n        }\r\n      };\r\n\r\n      this.socket.onerror = (error) => {\r\n        console.error('WebSocket connection error:', error);\r\n        this.connectionPromise = null;\r\n        reject(error);\r\n        this.attemptReconnect(roomName);\r\n      };\r\n\r\n      this.socket.onmessage = (event) => {\r\n        this.lastHeartbeat = Date.now();\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          this.handleMessage(data);\r\n        } catch (e) {\r\n          console.error('Failed to parse WebSocket message:', e);\r\n        }\r\n      };\r\n    });\r\n\r\n    return this.connectionPromise;\r\n  }\r\n\r\n  private handleMessage(data: any) {\r\n    if (data.type === 'reaction') {\r\n      this.reactionCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'user_status') {\r\n      this.userStatusCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'notification') {\r\n      this.notificationCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'message_edited') {\r\n      this.messageEditedCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'message_deleted') {\r\n      this.messageDeletedCallbacks.forEach(callback => callback(data));\r\n    } else if (data.type === 'read_receipt') {\r\n      this.readReceiptCallbacks.forEach(callback => callback(data));\r\n    } else {\r\n      // Assume it's a regular message\r\n      this.messageCallbacks.forEach(callback => callback(data));\r\n    }\r\n  }\r\n\r\n  private startHeartbeat() {\r\n    this.heartbeatInterval = setInterval(() => {\r\n      if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n        // Send ping every 30 seconds\r\n        this.socket.send(JSON.stringify({ type: 'ping' }));\r\n      }\r\n    }, 30000);\r\n\r\n    // Check for pong responses\r\n    this.socket!.onmessage = (event) => {\r\n      this.lastHeartbeat = Date.now();\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n        if (data.type === 'pong') {\r\n          return; // Heartbeat response, don't process as message\r\n        }\r\n        this.handleMessage(data);\r\n      } catch (e) {\r\n        console.error('Failed to parse WebSocket message:', e);\r\n      }\r\n    };\r\n  }\r\n\r\n  private stopHeartbeat() {\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n      this.heartbeatInterval = null;\r\n    }\r\n  }\r\n\r\n  private attemptReconnect(roomName: string) {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\r\n\r\n      this.reconnectTimeout = setTimeout(() => {\r\n        this.connect(roomName).catch(() => {\r\n          // Connection failed, will retry in next attempt\r\n        });\r\n      }, this.reconnectDelay * this.reconnectAttempts);\r\n    } else {\r\n      console.error('Max reconnection attempts reached');\r\n    }\r\n  }\r\n\r\n  disconnect() {\r\n    this.stopHeartbeat();\r\n    if (this.reconnectTimeout) {\r\n      clearTimeout(this.reconnectTimeout);\r\n      this.reconnectTimeout = null;\r\n    }\r\n    if (this.socket) {\r\n      this.socket.close(1000, 'Client disconnect');\r\n      this.socket = null;\r\n    }\r\n    this.connectionPromise = null;\r\n    this.reconnectAttempts = 0;\r\n  }\r\n\r\n  sendMessage(message: any) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        message: message.message,\r\n        reply_to: message.reply_to\r\n      }));\r\n    }\r\n  }\r\n\r\n  sendReaction(messageId: number, emoji: string) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'reaction',\r\n        message_id: messageId,\r\n        emoji\r\n      }));\r\n    }\r\n  }\r\n\r\n  sendReadReceipt(messageId: number) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'read_receipt',\r\n        message_id: messageId\r\n      }));\r\n    }\r\n  }\r\n\r\n  editMessage(messageId: number, content: string) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'edit_message',\r\n        message_id: messageId,\r\n        content\r\n      }));\r\n    }\r\n  }\r\n\r\n  deleteMessage(messageId: number) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        type: 'delete_message',\r\n        message_id: messageId\r\n      }));\r\n    }\r\n  }\r\n\r\n  replyToMessage(messageId: number, content: string, replyToId?: number) {\r\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n      this.socket.send(JSON.stringify({\r\n        message: content,\r\n        reply_to: replyToId\r\n      }));\r\n    }\r\n  }\r\n\r\n  onMessage(callback: (data: any) => void) {\r\n    this.messageCallbacks.push(callback);\r\n  }\r\n\r\n  onReaction(callback: (data: any) => void) {\r\n    this.reactionCallbacks.push(callback);\r\n  }\r\n\r\n  onUserStatus(callback: (data: any) => void) {\r\n    this.userStatusCallbacks.push(callback);\r\n  }\r\n\r\n  onNotification(callback: (data: any) => void) {\r\n    this.notificationCallbacks.push(callback);\r\n  }\r\n\r\n  onMessageEdited(callback: (data: any) => void) {\r\n    this.messageEditedCallbacks.push(callback);\r\n  }\r\n\r\n  onMessageDeleted(callback: (data: any) => void) {\r\n    this.messageDeletedCallbacks.push(callback);\r\n  }\r\n\r\n  onReadReceipt(callback: (data: any) => void) {\r\n    this.readReceiptCallbacks.push(callback);\r\n  }\r\n\r\n  off(event: string, callback?: (data: any) => void) {\r\n    let callbacks: ((data: any) => void)[] = [];\r\n    switch (event) {\r\n      case 'message':\r\n        callbacks = this.messageCallbacks;\r\n        break;\r\n      case 'reaction':\r\n        callbacks = this.reactionCallbacks;\r\n        break;\r\n      case 'user_status':\r\n        callbacks = this.userStatusCallbacks;\r\n        break;\r\n      case 'notification':\r\n        callbacks = this.notificationCallbacks;\r\n        break;\r\n      case 'message_edited':\r\n        callbacks = this.messageEditedCallbacks;\r\n        break;\r\n      case 'message_deleted':\r\n        callbacks = this.messageDeletedCallbacks;\r\n        break;\r\n      case 'read_receipt':\r\n        callbacks = this.readReceiptCallbacks;\r\n        break;\r\n    }\r\n    if (callback) {\r\n      const index = callbacks.indexOf(callback);\r\n      if (index > -1) {\r\n        callbacks.splice(index, 1);\r\n      }\r\n    } else {\r\n      callbacks.length = 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport default new WebSocketService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}